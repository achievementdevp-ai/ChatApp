<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>tapApp</title>
    <style>
        /* CSS: General Styling */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            height: 100dvh; 
            width: 100%;
            margin: 0;
            overflow: hidden;
        }

        /* --- LOGIN SCREEN STYLES --- */
        #login-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .login-card {
            background: white;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            text-align: center;
            width: 85%;
            max-width: 320px;
        }

        .login-card h2 {
            margin-top: 0;
            color: #333;
            margin-bottom: 5px;
        }

        .login-input {
            width: 100%;
            padding: 14px;
            margin: 15px 0;
            border: 2px solid #ddd;
            border-radius: 12px;
            box-sizing: border-box;
            font-size: 16px; /* Prevents iOS zoom */
            outline: none;
            transition: border-color 0.3s;
            -webkit-appearance: none;
        }

        .login-input:focus {
            border-color: #4a90e2;
        }

        .login-btn {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 14px;
            width: 100%;
            border-radius: 12px;
            font-size: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }

        .login-btn:hover {
            background: #357abd;
        }

        #error-message {
            color: #d93025;
            font-size: 14px;
            margin-top: 10px;
            min-height: 20px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* --- CHAT STYLES --- */
        #chat-container {
            width: 100%;
            max-width: 600px;
            background: white;
            display: none; /* Hidden until login */
            flex-direction: column;
            height: 100%;
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.05);
        }

        header {
            background: #4a90e2;
            color: white;
            padding: 10px 15px 15px 15px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            flex-shrink: 0;
            z-index: 10;
        }

        header h1 {
            margin: 0 0 10px 0;
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 0.5px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* --- CALL BUTTON IN HEADER --- */
        #call-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.4);
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: none; /* Hidden by default, shown on login */
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            position: absolute;
            right: 15px;
            top: 0;
            transition: all 0.2s;
        }

        #call-btn:active {
            background: rgba(255,255,255,0.4);
            transform: scale(0.95);
        }

        /* --- STATUS ROW --- */
        .status-row {
            display: flex;
            gap: 15px;
            width: 100%;
            justify-content: center;
        }

        .user-pill {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            font-weight: 500;
            transition: background 0.3s;
        }

        .user-pill.active-user {
            background: rgba(255, 255, 255, 0.35);
            border: 1px solid rgba(255,255,255,0.4);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #9aa0a6; /* Default Gray (Offline) */
            transition: background-color 0.3s;
            box-shadow: 0 0 2px rgba(0,0,0,0.2);
        }

        .status-dot.online {
            background-color: #31a24c; /* Green (Online) */
            box-shadow: 0 0 4px rgba(49, 162, 76, 0.6);
        }

        /* --- CALL OVERLAY STYLES --- */
        #call-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(20, 20, 25, 0.95);
            backdrop-filter: blur(10px);
            z-index: 2000;
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            transition: opacity 0.3s;
        }

        .call-avatar {
            width: 120px;
            height: 120px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .call-status {
            font-size: 24px;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .call-substatus {
            font-size: 16px;
            color: rgba(255,255,255,0.6);
            margin-bottom: 60px;
        }

        .call-controls {
            display: flex;
            gap: 40px;
        }

        .call-action-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .call-action-btn:active {
            transform: scale(0.9);
        }

        .btn-accept {
            background: #31a24c;
            color: white;
        }

        .btn-decline {
            background: #d93025;
            color: white;
        }

        /* Pulse Animation for Ringing */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(118, 75, 162, 0.4); }
            70% { box-shadow: 0 0 0 20px rgba(118, 75, 162, 0); }
            100% { box-shadow: 0 0 0 0 rgba(118, 75, 162, 0); }
        }

        .pulsing .call-avatar {
            animation: pulse 1.5s infinite;
        }

        /* --- MESSAGES --- */
        #message-window {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            background-color: #fff;
            padding-bottom: 20px;
            -webkit-overflow-scrolling: touch;
        }

        .message {
            max-width: 75%;
            padding: 0; 
            font-size: 15px;
            line-height: 1.4;
            word-wrap: break-word;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .message.sent {
            align-self: flex-end;
            align-items: flex-end; 
        }

        .message.received {
            align-self: flex-start;
            align-items: flex-start; 
        }

        .msg-bubble {
            padding: 10px 15px;
            border-radius: 18px;
            position: relative;
            display: inline-block;
            max-width: 100%;
        }

        .message.sent .msg-bubble {
            background-color: #0084ff;
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message.received .msg-bubble {
            background-color: #e4e6eb;
            color: black;
            border-bottom-left-radius: 4px;
        }

        .msg-content {
            display: flex;
            align-items: flex-end; 
            gap: 6px;
            justify-content: flex-end; 
        }

        .message.received .msg-content {
            justify-content: flex-start; 
        }

        .sender-name {
            font-size: 11px;
            margin-bottom: 4px;
            opacity: 0.7;
            display: block;
            font-weight: 600;
            margin-left: 2px;
        }

        .status-icon {
            width: 18px;
            height: 18px;
            flex-shrink: 0; 
            opacity: 0.8;
            margin-bottom: 2px; 
        }

        .status-icon svg {
            fill: #a3d2fc; 
            width: 100%;
            height: 100%;
        }

        /* --- TIMESTAMP STYLES --- */
        .msg-time {
            font-size: 11px; /* Increased from 10px to fit text better */
            opacity: 0.7;
            margin-bottom: 2px;
            margin-left: 6px; /* Add separation from text/icon */
            white-space: nowrap;
        }

        #input-area {
            padding: 12px 15px;
            border-top: 1px solid #ddd;
            display: flex;
            gap: 10px;
            background: white;
            align-items: center;
            flex-shrink: 0;
        }

        input[type="text"] {
            flex: 1;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 24px;
            outline: none;
            font-size: 16px !important;
            -webkit-appearance: none;
        }

        input[type="text"]:focus {
            border-color: #0084ff;
        }

        #send-btn {
            background: #0084ff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 24px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            flex-shrink: 0;
            transition: background 0.2s;
            height: 42px;
            line-height: 20px;
        }

        #send-btn:hover {
            background: #0073e6;
        }

        #send-btn:active {
            transform: scale(0.96);
        }

        /* Hidden Audio Element */
        #remoteAudio {
            display: none;
        }
    </style>
</head>
<body>

    <!-- LOGIN OVERLAY -->
    <div id="login-overlay">
        <div class="login-card">
            <h2>Login</h2>

            <input type="text" id="login-username" class="login-input" placeholder="Enter username..." autocomplete="off">

            <button id="login-btn" class="login-btn">Enter name</button>

            <div id="error-message">Access Denied: User not allowed.</div>
        </div>
    </div>

    <!-- CHAT CONTAINER -->
    <div id="chat-container">
        <header>
            <h1>
                Apptap
                <!-- CALL BUTTON -->
                <button id="call-btn" title="Start Call">ðŸ“ž</button>
            </h1>
            <div class="status-row">
                <div id="pill-bob" class="user-pill">
                    <div id="dot-bob" class="status-dot"></div>
                    Bob
                </div>
                <div id="pill-alice" class="user-pill">
                    <div id="dot-alice" class="status-dot"></div>
                    Alice
                </div>
            </div>
        </header>

        <div id="message-window"></div>

        <div id="input-area">
            <input type="text" id="message-input" placeholder="Type a message..." autocomplete="off">
            <button id="send-btn">Send</button>
        </div>

        <!-- CALL INTERFACE OVERLAY -->
        <div id="call-overlay">
            <div class="call-avatar" id="call-avatar-text">?</div>
            <div class="call-status" id="call-status-text">Calling...</div>
            <div class="call-substatus" id="call-timer">00:00</div>
            
            <div class="call-controls" id="call-controls-ring">
                <button class="call-action-btn btn-decline" id="btn-reject">âœ–</button>
                <button class="call-action-btn btn-accept" id="btn-accept" style="display:none">âœ”</button>
            </div>

            <!-- Connected Controls -->
            <div class="call-controls" id="call-controls-active" style="display:none">
                <button class="call-action-btn btn-decline" id="btn-end">ðŸ“ž</button>
            </div>
        </div>

        <!-- Remote Audio Stream -->
        <audio id="remoteAudio" autoplay playsinline></audio>
    </div>

    <!-- JAVASCRIPT Logic -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { 
            getFirestore, 
            collection, 
            addDoc, 
            query, 
            orderBy, 
            onSnapshot,
            serverTimestamp,
            doc,
            setDoc,
            updateDoc,
            where,
            deleteDoc,
            getDoc
        } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDsF91R4dJTrA4Y1DX4wuVKUflJgNt_8U4",
            authDomain: "logger-ba55c.firebaseapp.com",
            projectId: "logger-ba55c",
            storageBucket: "logger-ba55c.firebasestorage.app",
            messagingSenderId: "329912268654",
            appId: "1:329912268654:web:8dfc61cae5e677c906737f"
        };

        let db;
        let username = "";
        let heartbeatInterval;
        let currentCallId = null;
        let callTimerInterval = null;
        let callSeconds = 0;
        let unsubscribeCallListener = null; // To detach specific call listener

        // --- WEBRTC VARIABLES ---
        let peerConnection = null;
        let localStream = null;
        let remoteStream = null;
        
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        const loginOverlay = document.getElementById('login-overlay');
        const loginInput = document.getElementById('login-username');
        const loginBtn = document.getElementById('login-btn');
        const errorMsg = document.getElementById('error-message');
        const chatContainer = document.getElementById('chat-container');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        const messageWindow = document.getElementById('message-window');
        const pillBob = document.getElementById('pill-bob');
        const dotBob = document.getElementById('dot-bob');
        const pillAlice = document.getElementById('pill-alice');
        const dotAlice = document.getElementById('dot-alice');

        // Call Elements
        const callBtn = document.getElementById('call-btn');
        const callOverlay = document.getElementById('call-overlay');
        const callAvatarText = document.getElementById('call-avatar-text');
        const callStatusText = document.getElementById('call-status-text');
        const callTimerDisplay = document.getElementById('call-timer');
        const btnReject = document.getElementById('btn-reject');
        const btnAccept = document.getElementById('btn-accept');
        const btnEnd = document.getElementById('btn-end');
        const controlsRing = document.getElementById('call-controls-ring');
        const controlsActive = document.getElementById('call-controls-active');
        const remoteAudio = document.getElementById('remoteAudio');

        function attemptLogin() {
            const inputName = loginInput.value.trim().toLowerCase();

            if (inputName === 'bob' || inputName === 'alice') {
                username = inputName;
                loginOverlay.style.display = 'none';
                chatContainer.style.display = 'flex';

                if (username === 'bob') {
                    pillBob.classList.add('active-user');
                } else {
                    pillAlice.classList.add('active-user');
                }

                callBtn.style.display = 'flex';

                initChatApp();
            } else {
                errorMsg.style.opacity = '1';
                loginInput.style.borderColor = '#d93025';
                const card = document.querySelector('.login-card');
                card.animate([
                    { transform: 'translateX(0)' },
                    { transform: 'translateX(-10px)' },
                    { transform: 'translateX(10px)' },
                    { transform: 'translateX(0)' }
                ], { duration: 300 });
            }
        }

        loginBtn.addEventListener('click', attemptLogin);
        loginInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') attemptLogin();
            errorMsg.style.opacity = '0';
            loginInput.style.borderColor = '#ddd';
        });

        // --- CALL SYSTEM LOGIC ---

        function formatTime(totalSeconds) {
            const m = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
            const s = (totalSeconds % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        }

        function startCallTimer() {
            callSeconds = 0;
            callTimerDisplay.textContent = "00:00";
            clearInterval(callTimerInterval);
            callTimerInterval = setInterval(() => {
                callSeconds++;
                callTimerDisplay.textContent = formatTime(callSeconds);
            }, 1000);
        }

        function stopCallTimer() {
            clearInterval(callTimerInterval);
        }

        function resetCallUI() {
            callOverlay.style.display = 'none';
            callOverlay.classList.remove('pulsing');
            stopCallTimer();
            currentCallId = null;
            if (unsubscribeCallListener) {
                unsubscribeCallListener(); // Stop listening to this specific call
                unsubscribeCallListener = null;
            }
        }

        // --- WEBRTC FUNCTIONS ---

        async function setupMedia() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                localStream = stream;
                return stream;
            } catch (err) {
                console.error("Error accessing media devices.", err);
                alert("Could not access microphone. Please allow permissions.");
                throw err;
            }
        }

        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(rtcConfig);

            // Add local stream tracks to connection
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
            }

            // Handle incoming stream
            peerConnection.ontrack = (event) => {
                console.log("Received remote track");
                remoteAudio.srcObject = event.streams[0];
            };

            // Handle ICE Candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    // Send candidate to Firestore
                    // We store candidates in a sub-collection 'candidates' inside the call doc
                    const candidateRef = collection(db, `calls/${currentCallId}/candidates`);
                    addDoc(candidateRef, event.candidate.toJSON());
                }
            };

            peerConnection.onconnectionstatechange = () => {
                if (peerConnection.connectionState === 'disconnected') {
                    hangupLocal();
                }
            };
        }

        async function initiateCall() {
            const targetUser = username === 'bob' ? 'alice' : 'bob';
            
            const targetDot = targetUser === 'bob' ? dotBob : dotAlice;
            if (!targetDot.classList.contains('online')) {
                alert(`${targetUser.charAt(0).toUpperCase() + targetUser.slice(1)} is offline.`);
                return;
            }

            try {
                // 1. Setup Media
                await setupMedia();
                
                // 2. Create Call Doc
                const docRef = await addDoc(collection(db, "calls"), {
                    caller: username,
                    callee: targetUser,
                    status: 'ringing',
                    createdAt: serverTimestamp()
                });
                
                currentCallId = docRef.id;
                showOutgoingUI(targetUser);

                // 3. Listen for this specific call (to handle answer/end)
                listenForCallUpdates(currentCallId, true);

                // 4. Setup WebRTC
                createPeerConnection();

                // 5. Create Offer
                const offerDescription = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offerDescription);

                const offer = {
                    sdp: offerDescription.sdp,
                    type: offerDescription.type,
                };

                await updateDoc(doc(db, "calls", currentCallId), { offer });

                // 6. Listen for Answer
                const callDoc = doc(db, "calls", currentCallId);
                onSnapshot(callDoc, (snapshot) => {
                    const data = snapshot.data();
                    if (!peerConnection.currentRemoteDescription && data?.answer) {
                        const answerDescription = new RTCSessionDescription(data.answer);
                        peerConnection.setRemoteDescription(answerDescription);
                    }
                });

                // 7. Listen for Remote ICE Candidates
                const candidatesRef = collection(db, `calls/${currentCallId}/candidates`);
                const qCandidates = query(candidatesRef, where("type", "==", "host")); // Listen for Callee's candidates (type 'host' usually or just filter logic)
                // Actually simpler: just listen to all candidates and add them if they aren't ours.
                // For this simple 2-person app, we can just listen to all candidates in the subcollection.
                onSnapshot(candidatesRef, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            const candidate = new RTCIceCandidate(change.doc.data());
                            peerConnection.addIceCandidate(candidate);
                        }
                    });
                });

            } catch (e) {
                console.error("Error initiating call: ", e);
                hangupLocal();
            }
        }

        async function answerCall() {
            if (!currentCallId) return;

            try {
                // 1. Setup Media
                await setupMedia();

                // 2. Setup WebRTC
                createPeerConnection();

                // 3. Get Offer
                const callDoc = await getDoc(doc(db, "calls", currentCallId));
                const callData = callDoc.data();

                const offerDescription = callData.offer;
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offerDescription));

                // 4. Create Answer
                const answerDescription = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answerDescription);

                const answer = {
                    type: answerDescription.type,
                    sdp: answerDescription.sdp,
                };

                await updateDoc(doc(db, "calls", currentCallId), { answer, status: 'connected' });

                // 5. Listen for Caller ICE Candidates
                const candidatesRef = collection(db, `calls/${currentCallId}/candidates`);
                onSnapshot(candidatesRef, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            const candidate = new RTCIceCandidate(change.doc.data());
                            peerConnection.addIceCandidate(candidate);
                        }
                    });
                });

            } catch (e) {
                console.error("Error answering call: ", e);
                hangupLocal();
            }
        }

        // Listens to the specific call document to handle End events
        function listenForCallUpdates(callId, isCaller) {
            const docRef = doc(db, "calls", callId);
            unsubscribeCallListener = onSnapshot(docRef, (docSnap) => {
                const data = docSnap.data();
                
                // Handle Call Ended by other party
                if (data.status === 'ended') {
                    hangupLocal();
                    return;
                }

                // Handle Status Change to Connected (for the caller)
                if (isCaller && data.status === 'connected') {
                    showConnectedUI();
                }
            });
        }

        function hangupLocal() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            remoteAudio.srcObject = null;
            resetCallUI();
        }

        async function endCall() {
            if (currentCallId) {
                // Update DB first so other person knows
                await updateDoc(doc(db, "calls", currentCallId), {
                    status: 'ended'
                });
            }
            hangupLocal();
        }


        // --- UI LOGIC ---

        function showOutgoingUI(target) {
            callOverlay.style.display = 'flex';
            callOverlay.classList.add('pulsing');
            callAvatarText.textContent = target.charAt(0).toUpperCase();
            callStatusText.textContent = `Calling ${target}...`;
            callTimerDisplay.textContent = "Ringing";
            
            controlsRing.style.display = 'flex';
            btnAccept.style.display = 'none';
            controlsActive.style.display = 'none';
        }

        function showIncomingUI(caller) {
            callOverlay.style.display = 'flex';
            callOverlay.classList.add('pulsing');
            callAvatarText.textContent = caller.charAt(0).toUpperCase();
            callStatusText.textContent = `${caller} is calling...`;
            callTimerDisplay.textContent = "Incoming Call";

            controlsRing.style.display = 'flex';
            btnAccept.style.display = 'flex'; 
            controlsActive.style.display = 'none';
        }

        function showConnectedUI() {
            callOverlay.classList.remove('pulsing');
            callStatusText.textContent = "Connected";
            startCallTimer();

            controlsRing.style.display = 'none';
            controlsActive.style.display = 'flex';
        }

        function listenForCalls() {
            // Query for active calls involving me
            const q = query(collection(db, "calls"), where("status", "==", "ringing"));
            
            onSnapshot(q, (snapshot) => {
                // If we are already in a call, ignore new incoming calls
                if (currentCallId) return;

                snapshot.forEach((docSnap) => {
                    const data = docSnap.data();
                    
                    // If I am the callee
                    if (data.callee === username) {
                        currentCallId = docSnap.id;
                        showIncomingUI(data.caller);
                        
                        // Start listening to this specific doc for updates (like 'ended')
                        listenForCallUpdates(currentCallId, false);
                    }
                });
            });
        }

        // Call Event Listeners
        callBtn.addEventListener('click', initiateCall);
        btnReject.addEventListener('click', endCall);
        btnAccept.addEventListener('click', answerCall);
        btnEnd.addEventListener('click', endCall);


        // --- CHAT & PRESENCE LOGIC ---

        function initChatApp() {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);

            listenForCalls();
            initPresenceSystem(db, username);

            async function sendMessage() {
                const text = messageInput.value.trim();
                if (text !== "") {
                    try {
                        sendBtn.disabled = true;
                        sendBtn.style.opacity = "0.7";

                        await addDoc(collection(db, "messages"), {
                            text: text,
                            sender: username,
                            createdAt: serverTimestamp()
                        });
                        messageInput.value = "";

                        sendBtn.disabled = false;
                        sendBtn.style.opacity = "1";
                        messageInput.focus();

                    } catch (e) {
                        console.error("Error adding document: ", e);
                        sendBtn.disabled = false;
                        sendBtn.style.opacity = "1";
                    }
                }
            }

            sendBtn.addEventListener('click', sendMessage);
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendMessage();
            });

            const q = query(collection(db, "messages"), orderBy("createdAt"));

            const formatMessageTime = (timestamp) => {
                if (!timestamp) return '';
                const date = timestamp.toDate();
                const now = new Date();
                const isSameDay = (d1, d2) => {
                    return d1.getFullYear() === d2.getFullYear() &&
                           d1.getMonth() === d2.getMonth() &&
                           d1.getDate() === d2.getDate();
                };
                const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                if (isSameDay(date, now)) return timeStr;
                const yesterday = new Date(now);
                yesterday.setDate(yesterday.getDate() - 1);
                if (isSameDay(date, yesterday)) return `Yesterday, ${timeStr}`;
                const dateStr = date.toLocaleDateString([], { month: 'short', day: 'numeric' });
                return `${dateStr}, ${timeStr}`;
            };

            onSnapshot(q, (snapshot) => {
                messageWindow.innerHTML = ""; 
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    if(!data.text) return; 
                    const msgDiv = document.createElement('div');
                    const isMe = data.sender === username;
                    msgDiv.classList.add('message');
                    msgDiv.classList.add(isMe ? 'sent' : 'received');
                    const safeText = data.text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    const timeStr = formatMessageTime(data.createdAt);
                    const doubleCheckIcon = `
                        <div class="status-icon" title="Delivered">
                            <svg viewBox="0 0 24 24">
                                <path d="M18 7l-1.41-1.41-6.34 6.34 1.41 1.41L18 7zm4.24-1.41L11.66 16.17 7.48 12l-1.41 1.41L11.66 19l12-12-1.42-1.41zM.41 13.41L6 19l1.41-1.41L1.83 12 .41 13.41z"/>
                            </svg>
                        </div>
                    `;
                    let contentHtml = `<span>${safeText}</span>`;
                    if (isMe) contentHtml += doubleCheckIcon;
                    contentHtml += `<span class="msg-time">${timeStr}</span>`;
                    msgDiv.innerHTML = `
                        <span class="sender-name">${data.sender}</span>
                        <div class="msg-bubble">
                            <div class="msg-content">${contentHtml}</div>
                        </div>
                    `;
                    messageWindow.appendChild(msgDiv);
                });
                messageWindow.scrollTop = messageWindow.scrollHeight;
            });
        }

        function initPresenceSystem(db, currentUser) {
            const usersRef = collection(db, "users");
            const myUserRef = doc(db, "users", currentUser);

            const goOnline = async () => {
                try {
                    await setDoc(myUserRef, {
                        state: 'online',
                        lastSeen: serverTimestamp()
                    }, { merge: true });
                } catch (e) { console.error("Go Online Error:", e); }
            };

            const goOffline = async () => {
                try {
                    await setDoc(myUserRef, {
                        state: 'offline',
                        lastSeen: serverTimestamp()
                    }, { merge: true });
                } catch (e) { console.error("Go Offline Error:", e); }
            };

            const startHeartbeat = () => {
                goOnline();
                heartbeatInterval = setInterval(async () => {
                    try {
                        await updateDoc(myUserRef, { lastSeen: serverTimestamp() });
                    } catch (e) { console.error("Heartbeat Error:", e); }
                }, 30000);
            };

            const listenToUsers = () => {
                onSnapshot(usersRef, (snapshot) => {
                    const now = Date.now();
                    snapshot.forEach((docSnap) => {
                        const user = docSnap.id;
                        const data = docSnap.data();
                        let targetDot = null;
                        if (user === 'bob') targetDot = dotBob;
                        if (user === 'alice') targetDot = dotAlice;
                        if (targetDot) {
                            let lastSeen = 0;
                            if (data.lastSeen && typeof data.lastSeen.toMillis === 'function') {
                                lastSeen = data.lastSeen.toMillis();
                            }
                            const timeDiff = now - lastSeen;
                            if (timeDiff < 60000) {
                                targetDot.classList.add('online');
                            } else {
                                targetDot.classList.remove('online');
                            }
                        }
                    });
                });
            };

            startHeartbeat();
            listenToUsers();

            window.addEventListener('beforeunload', () => {
                goOffline();
                clearInterval(heartbeatInterval);
                if (currentCallId) {
                    updateDoc(doc(db, "calls", currentCallId), { status: 'ended' });
                }
            });
        }
    </script>
</body>
</html>
